---
title: "FAMe Transcriptomics"
output: html_document
date: "2025-04-02"
---
# Libraries
```{r load library, include=FALSE}

# Load styling/formatting packages
library(prettydoc)  # For nicely formatted R Markdown reports

# Core RNA-seq analysis
library(DESeq2)
library(limma)
library(Mfuzz)
library(DEGreport)
library(RNAseqQC)

# Gene annotation and enrichment
library(biomaRt)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(AnnotationHub)
library(clusterProfiler)
library(enrichplot)
library(msigdbr)
library(DOSE)

# Motif and regulatory sequence analysis
library(TFBSTools)
library(JASPAR2022)
library(BSgenome.Hsapiens.UCSC.hg38)
library(GenomicRanges)
library(Biostrings)
library(GenomicFeatures)

# Data handling
library(tibble)
library(readxl)
library(reshape2)
library(tidyverse)  # Loads dplyr, ggplot2, tidyr, etc.
library(splines)

# Visualization
library(ggpubr)
library(ggrepel)
library(cowplot)
library(EnhancedVolcano)
library(pheatmap)
library(patchwork)
library(ggbreak)
library(magick)

# Load custom functions
source("Functions.R")

set.seed(42)
```

# Installation

```{r}
# Install BiocManager if not already installed
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

# Install Bioconductor packages
BiocManager::install(c("DESeq2", 
                       "clusterProfiler", 
                       "enrichplot", 
                       "DOSE",
                       "msigdbr",
                       "RNAseqQC",
                       "limma"))

# Install CRAN packages
install.packages(c("prettydoc", 
                   "tidyverse", 
                   "ggpubr", 
                   "ggplot2", 
                   "ggrepel", 
                   "cowplot"))

# Install DEGreport from Bioconductor
BiocManager::install("DEGreport")

# Load all libraries to verify installation
library(prettydoc)
library(DESeq2)
library(tidyverse)
library(ggpubr)
library(ggplot2)
library(ggrepel)
library(cowplot)
library(DEGreport)
library(clusterProfiler)
library(enrichplot)
library(DOSE)
library(msigdbr)
library(RNAseqQC)
library(readxl)

print("All packages installed and loaded successfully!")
```

# Merge data

Load the transcript counts, the sample data, and the transcript to gene ID conversion table.
```{r}
# Load 2024 Counts data
cts_allSexes <- read_rds("Data/cts_allSexes.rds")
cts1 <- cts_allSexes[1:48] %>% 
  dplyr::select(-c("FL-92")) #females only with outliers removed

# Load 2023 Counts data
cts2 <- read.csv("Data/cts_female_pheno.csv", check.names = FALSE)
rownames(cts2) <- cts2[[1]]
cts2 <- cts2[ , -1]

# Merge counts data
cts1 <- cts1 %>% rownames_to_column(var = "GeneID")# Add gene ID as a column for merging
cts2 <- cts2 %>% rownames_to_column(var = "GeneID")
cts_merged <- full_join(cts1, cts2, by = "GeneID") # Full join by gene ID (keeps all rows)
cts_merged <- cts_merged %>% column_to_rownames(var = "GeneID") # Move gene ID back to rownames
cts_merged[is.na(cts_merged)] <- 0 # Converts NA to 0

cts <- cts_merged
cts <- saveRDS(cts, "Data/counts_data.rds")

# Pheno data

col <- read_excel("Data/pheno_data.xlsx") %>% 
  filter(! ColName %in% c("FL-92")) # outlier removed
pheno_data <- saveRDS(col, "Data/pheno_data.rds")

# check rownames of sample data equal column names of count matrix
pheno_data <- read_rds("Data/pheno_data.rds") 
rownames(pheno_data) <- paste0(pheno_data$ColName)
all(rownames(pheno_data) == colnames(cts))

head(cts)
head(pheno_data)

```

# Load data

```{r}

cts <- read_rds("Data/counts_data.rds")
pheno_data <- read_rds("Data/pheno_data.rds") 

# Set factors and reference level
pheno_data$Agecat <- as.factor(pheno_data$Agecat)
pheno_data$Agecat <- relevel(pheno_data$Agecat, ref = "18-29")
pheno_data$ColName <- as.factor(pheno_data$ColName)
pheno_data$Menopause <- as.factor(pheno_data$Menopause)
pheno_data$Batch <- as.factor(pheno_data$Batch)
pheno_data$E2 <- as.numeric(pheno_data$E2)
pheno_data$FEI <- as.numeric(pheno_data$FEI)
pheno_data$TT <- as.numeric(pheno_data$TT)
pheno_data$FAI <- as.numeric(pheno_data$FAI)
pheno_data$Prog <- as.numeric(pheno_data$Prog)
pheno_data$TE2 <- as.numeric(pheno_data$TE2)

```

# Age Analysis

## Continuous*

### Volcano

This analysis runs DESeq with age as a continuous variable and produces a volcano plot to see genes that are significantly associated with age. Log fold change here represents the B coefficient of the relationship.

```{r}
dds <- DESeqDataSetFromMatrix(countData = cts, colData = pheno_data, design = ~ Batch + Age)

dds_results_list <- list()

x <- dim(dds)

keep <- rowMeans(counts(dds)) >= 10
dds <- dds[keep,]

dds <- estimateSizeFactors(dds)

# Normalisation
vsd <- vst(dds, blind=FALSE)

cat("---- Table Dimensions ---- ", "\n",
    "Before filtering for lowcounts: ", x, "\n",
    "After filtering for lowcounts:  ", dim(dds))

dds <- DESeq(dds)

# Pre-map gene names once
ensembl_ids <- rownames(cts)
gene_names <- mapIds(
  org.Hs.eg.db,
  keys = ensembl_ids,
  column = "SYMBOL",
  keytype = "ENSEMBL",
  multiVals = "first"
)

# Extract results
res <- results(dds, name = "Age")
res_df <- as.data.frame(res)
res_df$ensembl_id <- rownames(res_df)
  
res_df$gene_name <- mapIds(
    org.Hs.eg.db,
    keys = res_df$ensembl_id,
    column = "SYMBOL",
    keytype = "ENSEMBL",
    multiVals = "first"
  )
  
  # Save all results
  write.csv(res_df, paste0("Ageing/Continuous/Age_associations.csv"), row.names = FALSE)
  
  # Save list of all genes
  
  all_genes <- (res_df$gene_name)
  saveRDS(all_genes, "Ageing/All_genes.rds")
  
  all_gene_ensembl <-(res_df$ensembl_id)
  
  # Save significant only
  age_sig_df <- subset(res_df, padj < 0.05)
  saveRDS(age_sig_df$gene_name, "Ageing/Age_associated_genes.rds")
  
  age_genes_ensembl <- age_sig_df$ensembl_id
  
  # Save in list
  dds_results_list[["Age"]] <- res_df
  
   # Count significant genes based on p-value cutoff
  sig_genes <- sum(res_df$padj < 0.05, na.rm = TRUE)
  
  # Get maximum absolute fold-change for xlim setting
  max_abs_fc <- max(abs(res_df$log2FoldChange), na.rm = TRUE)
  
# EnhancedVolcano plot (focused on p-value significance only)
 
 num_up   <- sum(res_df$padj < 0.05 & res_df$log2FoldChange > 0, na.rm = TRUE)
 num_down <- sum(res_df$padj < 0.05 & res_df$log2FoldChange < 0, na.rm = TRUE)

 keyvals <- ifelse(
  res_df$padj < 0.05 & res_df$log2FoldChange > 0, "red",
  ifelse(res_df$padj < 0.05 & res_df$log2FoldChange < 0, "blue", "darkgrey")
)

# Force replace any NA colors with default
keyvals[is.na(keyvals)] <- "darkgrey"

# Assign labels only where color is valid (lengths must match!)
keyval_labels <- ifelse(
  keyvals == "red", paste0("Up (n=", num_up,")"),
  ifelse(keyvals == "blue", paste0("Down (n=", num_down, ")"), 
         ifelse(keyvals == "darkgrey", "NS", NA))
)

# Assign names explicitly — this ensures no `NA` legend keys are created
names(keyvals) <- keyval_labels

# Final check to remove any names that are NA
keyvals <- keyvals[!is.na(names(keyvals))]

volc_plot <- EnhancedVolcano(res_df, 
  x = "log2FoldChange", 
  y = "padj", 
  lab = NA, 
  pCutoff = 0.05,  
  FCcutoff = 0,
  gridlines.major = FALSE, 
  gridlines.minor = FALSE,
  caption = NULL,
  title = "Genes associated with age",
  subtitle = NULL,
  xlab = bquote("Log"[2]~"fold change per year"),
  xlim = c(-max_abs_fc, max_abs_fc),  
  colCustom = keyvals,
  legendPosition = "top"
) + theme(
  axis.text.x = element_text(color = "black"),
  axis.text.y = element_text(color = "black")
)

volc_plot
  
# Create summary table
summary_df <- data.frame(
  Total_Genes = sapply(dds_results_list, nrow),
  Significant_Genes = sapply(dds_results_list, function(x) sum(x$padj < 0.05, na.rm = TRUE)),
  Upregulated = sapply(dds_results_list, function(x) sum(x$padj < 0.05 & x$log2FoldChange > 0, na.rm = TRUE)),
  Downregulated = sapply(dds_results_list, function(x) sum(x$padj < 0.05 & x$log2FoldChange < 0, na.rm = TRUE))
)

write.csv(summary_df, "Ageing/Continuous/Analysis_Summary.csv", row.names = FALSE)
print(summary_df)

```
### Enrichment

#### ORA

```{r}
# Filter significant genes
sig_genes_df <- subset(res_df, padj < 0.05 & !is.na(padj))

entrez_ids <- mapIds(
  org.Hs.eg.db,
  keys = sig_genes_df$ensembl_id,
  column = "ENTREZID",
  keytype = "ENSEMBL",
  multiVals = "first"
)
entrez_ids <- na.omit(entrez_ids)

ego <- enrichGO(gene = entrez_ids,
                OrgDb = org.Hs.eg.db,
                ont = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff = 0.05,
                readable = TRUE)

# Save enrichment results to CSV
write.csv(as.data.frame(ego), "Ageing/Continuous/GO_Enrichment.csv", row.names = FALSE)

oradotplot <- dotplot(ego, showCategory = 20, title = "Gene Ontology Enrichment")
oradotplot
```
#### GSEA

```{r}
df <- res_df
gene_list <- df$log2FoldChange
names(gene_list) <- rownames(df)
gene_list<-na.omit(gene_list)
gene_list = sort(gene_list, decreasing = TRUE)
options(enrichment_force_universe = TRUE)
gse <- gseGO(geneList=gene_list, 
             ont ="BP", 
             keyType = "ENSEMBL", 
             minGSSize = 5, 
             maxGSSize = 800, 
             pvalueCutoff = 0.05, 
             verbose = TRUE, 
             OrgDb = org.Hs.eg.db, 
             pAdjustMethod = "BH")
require(DOSE)
gsedotplot <- dotplot(gse, showCategory=5, split=".sign") + facet_grid(.~.sign)
gsedotplot
```


### Merge figures

```{r}

# First, create your individual plots with labels
plot_A <- volc_plot + 
  ggtitle("Genes associated with age") +
  theme(
  plot.title = element_text(size = 16, face = "bold")
)

plot_B <- gsedotplot + 
  ggtitle("Gene set enrichment") + theme(
  plot.title = element_text(size = 16, face = "bold")
)

# Method 1: Save individual plots with cowplot labels
plot_A_labeled <- plot_grid(
  plot_A, 
  labels = "A", 
  label_size = 20,
  ncol = 1
)

plot_B_labeled <- plot_grid(
  plot_B, 
  labels = "B", 
  label_size = 20,
  ncol = 1
)

# Save individual plots
ggsave("Ageing/Continuous/Volcano.png", 
       plot = plot_A_labeled, 
       width = 8, height = 7, dpi = 300)

ggsave("Ageing/Continuous/Dotplot.png", 
       plot = plot_B_labeled, 
       width = 8, height = 7, dpi = 300)

# Read the saved images
img_A <- image_read("Ageing/Continuous/Volcano.png")
img_B <- image_read("Ageing/Continuous/Dotplot.png")

# Combine side by side
combined_image <- image_append(c(img_A, img_B), stack = FALSE)

# Save the combined image
image_write(combined_image, "Ageing/Continuous/Combined_Figure.png")

```


## DEseq

### DEseq object

Create a deseq object with count and bio data. The reference or "control" is set to 18-29.

```{r echo = T, results = 'hide'}

dds <- DESeqDataSetFromMatrix(countData = cts, colData = pheno_data, design = ~ Batch + Agecat)

x <- dim(dds)

keep <- rowMeans(counts(dds)) >= 10
dds <- dds[keep,]

dds <- estimateSizeFactors(dds)

# Normalisation
vsd <- vst(dds, blind=FALSE)

cat("---- Table Dimensions ---- ", "\n",
    "Before filtering for lowcounts: ", x, "\n",
    "After filtering for lowcounts:  ", dim(dds))
```

### Outliers

There is one outlier (FL-1) detected from the dendrogram.
```{r}

# detect outlier samples - hierarchical clustering
htree <- hclust(dist(t(assay(vsd))), method = "average")
groups <- cutree(htree, k=6) # cut tree into clusters

plot(htree, labels(groups))
# draw dendogram with red borders around the clusters
rect.hclust(htree, k=6, border="red")

```

### PCA plots

```{r }
beforePCA <- plotPCA(vsd, intgroup = "Batch")
beforePCA

assay(vsd) <- limma::removeBatchEffect(assay(vsd), vsd$Batch)
afterPCA <- plotPCA(vsd, intgroup = "Batch")
afterPCA

# First, create your individual plots with labels
plot_A <- beforePCA + 
  ggtitle("Before batch correction") +
  theme(
  plot.title = element_text(size = 16, face = "bold")
)

plot_B <- afterPCA + 
  ggtitle("After batch correction") + theme(
  plot.title = element_text(size = 16, face = "bold")
)

# Method 1: Save individual plots with cowplot labels
plot_A_labeled <- plot_grid(
  plot_A, 
  labels = "A", 
  label_size = 20,
  ncol = 1
)

plot_B_labeled <- plot_grid(
  plot_B, 
  labels = "B", 
  label_size = 20,
  ncol = 1
)

# Save individual plots
ggsave("Ageing/PCA/Before_PCA.png", 
       plot = plot_A_labeled, 
       width = 8, height = 7, dpi = 300)

ggsave("Ageing/PCA/After_PCA.png", 
       plot = plot_B_labeled, 
       width = 8, height = 7, dpi = 300)

# Read the saved images
img_A <- image_read("Ageing/PCA/Before_PCA.png") %>%
  image_background("white") %>%
  image_extent("2400x2100", gravity = "center")  # 8x7 inches at 300 dpi

img_B <- image_read("Ageing/PCA/After_PCA.png") %>%
  image_background("white") %>%
  image_extent("2400x2100", gravity = "center")

# Combine side by side
combined_image <- image_append(c(img_A, img_B), stack = FALSE)

# Save the combined image
image_write(combined_image, "Ageing/PCA/Batch_effects.png")


```

### Extracting results

Results are extracted with a pairwise comparison/contrast
```{r echo = T, results = 'hide'}
dds <- DESeq(dds)

T1_vs_T2 <- as.data.frame(results(dds, contrast = c("Agecat", "18-29", "30-39")))
T2_vs_T3 <- as.data.frame(results(dds, contrast = c("Agecat", "30-39", "40-49")))
T3_vs_T4 <- as.data.frame(results(dds, contrast = c("Agecat", "40-49", "50-59")))
T4_vs_T5 <- as.data.frame(results(dds, contrast = c("Agecat", "50-59", "60-69")))
T5_vs_T6 <- as.data.frame(results(dds, contrast = c("Agecat", "60-69", "70-80")))

ddsContrast_list <- list("18-29_vs_30-39"=T1_vs_T2,
                         "30-39_vs_40-49"=T2_vs_T3,
                         "40-49_vs_50-59"=T3_vs_T4,
                         "50-59_vs_60-69"=T4_vs_T5,
                         "60-69_vs_70-80"=T5_vs_T6)

# Read your existing data with differential expression results
deResults_list <- diff_expressed(ddsContrast_list, 0.05, 1)

# Get comparisons
comparison_names <- names(deResults_list)

# Process each comparison in the list
for (i in 1:length(deResults_list)) {
  # Extract Ensembl IDs from the current comparison
  # Assuming Ensembl IDs are in column A or as rownames
  if ("ensembl_id" %in% colnames(deResults_list[[i]])) {
    ensembl_ids <- deResults_list[[i]]$ensembl_id
  } else {
    ensembl_ids <- rownames(deResults_list[[i]])
  }
  
  # Map Ensembl IDs to gene symbols using AnnotationDbi
  gene_symbols <- mapIds(
    org.Hs.eg.db,
    keys = ensembl_ids,
    column = "SYMBOL",
    keytype = "ENSEMBL",
    multiVals = "first"
  )
  
  # Add gene symbols to the results
  if ("ensembl_id" %in% colnames(deResults_list[[i]])) {
    # If Ensembl IDs are in a column
    deResults_list[[i]]$gene_name <- gene_symbols[deResults_list[[i]]$ensembl_id]
  } else {
    # If Ensembl IDs are rownames
    deResults_list[[i]]$gene_name <- gene_symbols[rownames(deResults_list[[i]])]
  }
  
  # Save each comparison to a CSV named after the comparison
  comparison_name <- comparison_names[i]
  sanitized_name <- gsub("[^a-zA-Z0-9_]", "_", comparison_name)  # Replace invalid characters
  write.csv(deResults_list[[i]], paste0("Ageing/Results/DEseq/Agecat_DE_genes_", sanitized_name, ".csv"))
}

# Save the complete list as RDS
saveRDS(deResults_list, "Ageing/DEGs/Agecat_DE_genes_list.rds")

diffexpr_summary <- list()

for (i in 1:5) {
  notSig <- table(deResults_list[[i]]$diffexpressed)["NO"]
  upGenes <- table(deResults_list[[i]]$diffexpressed)["UP"]
  downGenes <- table(deResults_list[[i]]$diffexpressed)["DOWN"]*-1
  name <- gsub("_", " ", names(deResults_list[i]))
  name2 <- gsub("[Stage]", "", name)
 
  diffexpr_summary[[paste0(name)]]$Stage <- name2
  diffexpr_summary[[paste0(name)]]$Count <- upGenes
  diffexpr_summary[[paste0(name)]]$Expression <- "Up"

  diffexpr_summary[[paste0(name, "Down")]]$Stage <- name2
  diffexpr_summary[[paste0(name, "Down")]]$Count <- downGenes
  diffexpr_summary[[paste0(name, "Down")]]$Expression <- "Down"
 
  diffexpr_summary[[paste0(name, "NS")]]$Stage <- name2
  diffexpr_summary[[paste0(name, "NS")]]$Count <- notSig
  diffexpr_summary[[paste0(name, "NS")]]$Expression <- "NotSignificant"
}

diffexpr_summaryDF <- do.call(rbind.data.frame, diffexpr_summary) %>%
  group_by(Stage) %>% as.data.frame(.)

diffexpr_summaryDF2 <- diffexpr_summaryDF %>%
  tidyr::pivot_wider(names_from = Expression, values_from = Count) %>%
  mutate(Down = Down*-1) %>%
  mutate(TotalDiffExp = Up + Down) %>%
  mutate(TotalCounts = Up + Down + NotSignificant) %>%
  mutate(PerCentSignif = round(TotalDiffExp / TotalCounts, digits = 4)*100)

diffexpr_summaryDF2

lvl <- c(unique(diffexpr_summaryDF$Stage))

geneLevel <- ggplot(diffexpr_summaryDF[diffexpr_summaryDF$Expression != "NotSignificant",],
                    aes(x=factor(Stage, level= lvl)
                               , y=Count, fill=Expression)) +
  geom_bar(stat="identity", position="identity", alpha=0.90) +
  scale_fill_manual(values=c('Up' = "darkblue", 'Down' = "darkred"),
                    breaks = c("Up", "Down")) +
  #scale_fill_discrete(breaks=c('Up',"Down")) +
  geom_text(aes(label = abs(Count), vjust = ifelse(Count >= 0, -0.2, 1.2)),
            size = 3, colour = "#48494b") +
  theme_classic() +
  ggtitle("Expressed gene levels for each age group") +
  labs(subtitle = "") +
  ylab("Gene count") + xlab("Age") +
  theme(axis.text.x = element_text(angle = 0, size = 8, vjust = 0.5,
                                   colour = "#48494b"),
        axis.title = element_text(size = 12, colour = "#48494b"),
        axis.line = element_line(colour = "grey"),
       
        plot.title = element_text(face = "bold", size = 15, hjust = 0.5),
          panel.grid = element_blank())

geneLevel

pdf("Ageing/DEGs/DEGs.pdf",
    width = 7,
    height = 5)
geneLevel
dev.off()

# Lists of unique DE genes

list1 <- deResults_list$`18-29_vs_30-39` %>%
  filter(diffexpressed != "NO") %>%
  rownames(.)

list2 <- deResults_list$`30-39_vs_40-49` %>%
  filter(diffexpressed != "NO") %>%
  rownames(.)

list3 <- deResults_list$`40-49_vs_50-59` %>%
  filter(diffexpressed != "NO") %>%
  rownames(.)

list4 <- deResults_list$`50-59_vs_60-69` %>%
  filter(diffexpressed != "NO") %>%
  rownames(.)

list5 <- deResults_list$`60-69_vs_70-80` %>%
  filter(diffexpressed != "NO") %>%
  rownames(.)

ensembl_listDE <- unique(c(list1, list2, list3, list4, list5))


# number of unique DE genes from 18-29 to 70-80
length(ensembl_listDE)

```

## Linearity

### Non-linear genes

Biological question answered:

After accounting for batch, which genes show non-linear (i.e. spline) age trends that can’t be captured by a straight‐line change with age?


```{r}
dds <- DESeqDataSetFromMatrix(countData = cts,
                              colData = pheno_data,
                              design = ~ Batch + ns(Age, df = 3))

dds <- DESeq(dds,
             test    = "LRT",
             reduced = ~ Batch + Age)

res_lrt <- as.data.frame(results(dds))

# padj < 0.05 → spline fits significantly better → NON‐LINEAR genes
nonlinear_genes <- rownames(subset(res_lrt, padj < 0.05)) 
length(nonlinear_genes)
#120 at df=3, 109 at df=4 and 86 at df=2, therefore use df=3

# padj >= 0.05 → no evidence spline improves over linear → LINEAR genes
linear_genes    <- rownames(subset(res_lrt, padj >= 0.05)) 
length(linear_genes)
#22820 at df =3, 22793 at df=4, 20362 at df=2

all_genes <- rownames(subset(res_lrt, padj > 0.00)) 
length(all_genes)
#22935

saveRDS(linear_genes, "C:/Users/annab/OneDrive - Deakin University/PhD/Studies/FAMe Study/FAMe Data Analysis/R analysis/Transcriptome/Data/linear_genes.rds")
saveRDS(nonlinear_genes, "C:/Users/annab/OneDrive - Deakin University/PhD/Studies/FAMe Study/FAMe Data Analysis/R analysis/Transcriptome/Data/nonlinear_genes.rds")
saveRDS(all_genes, "C:/Users/annab/OneDrive - Deakin University/PhD/Studies/FAMe Study/FAMe Data Analysis/R analysis/Transcriptome/Data/all_genes.rds")
```

### Spline-based modeling

```{r}
dds <- DESeqDataSetFromMatrix(countData = cts,
                              colData = pheno_data,
                              design = ~ Batch + ns(Age, df = 3))
dds <- DESeq(dds)

spline_res <- lapply(resultsNames(dds), 
                     function(term) as.data.frame(results(dds, name = term)))
```

### Spline curves

```{r}
plot_gene_spline <- function(gene_id, dds_obj) {
  age_seq <- seq(min(colData(dds_obj)$Age), max(colData(dds_obj)$Age), length.out = 100)
  spline_basis <- predict(ns(colData(dds_obj)$Age, df = 3), newx = age_seq)

  coefs <- coef(lm(counts(dds_obj, normalized = TRUE)[gene_id, ] ~ ns(colData(dds_obj)$Age, df = 3)))
  fitted_vals <- spline_basis %*% coefs[-1] + coefs[1]

  df <- data.frame(age = age_seq, fitted = fitted_vals)

  ggplot(df, aes(x = age, y = fitted)) +
    geom_line(color = "steelblue", size = 1.2) +
    labs(title = paste("Fitted spline for", gene_id), x = "Age", y = "Normalized expression") +
    theme_minimal()
}

# Example:
plot_gene_spline("ENSG00000091831", dds) # linear
plot_gene_spline("ENSG00000005884", dds) # nonlinear

"ENSG00000091831" %in% linear_genes

```

## Clusters*

### LRT

Analyze all levels of a factor at once using [likelihood ratio test (LRT)](https://hbctraining.github.io/DGE_workshop/lessons/08_DGE_LRT.html) which is used to identify any genes that show change in expression across the different levels of age (linear and non-linear).

```{r fig.height=10, fig.width=13}
dds <- DESeqDataSetFromMatrix(countData = cts, colData = pheno_data, design = ~ Batch + Agecat)

dds_results_list <- list()

x <- dim(dds)

keep <- rowMeans(counts(dds)) >= 10
dds <- dds[keep,]

dds <- estimateSizeFactors(dds)

# Normalisation
vsd <- vst(dds, blind=FALSE)

cat("---- Table Dimensions ---- ", "\n",
    "Before filtering for lowcounts: ", x, "\n",
    "After filtering for lowcounts:  ", dim(dds))

coldataLRT <- as.data.frame(dds@colData)

dds_lrt <- DESeq(dds, test="LRT", reduced=~1)
res_lrt <- results(dds_lrt)

sig_res_LRT <- res_lrt %>%
               data.frame() %>%
               tibble::rownames_to_column(var="gene") %>%
               as_tibble() %>%
               filter(padj < 0.05)
 
# Get significant gene lists
sigLRT_genes <- sig_res_LRT %>%
  arrange(padj) %>%
  pull(gene)

saveRDS(sigLRT_genes, "C:/Users/annab/OneDrive - Deakin University/PhD/Studies/FAMe Study/FAMe Data Analysis/R analysis/Transcriptome/Data/all_sig_genes.rds")
```

### Cluster analysis

The first part takes ages so just load the RDS file back in. 

```{r fig.height=10, fig.width=13}

#sigLRT_genes <- readRDS("C:/Users/annab/OneDrive - Deakin University/PhD/Studies/FAMe Study/FAMe Data Analysis/R analysis/Transcriptome/Data/all_sig_genes.rds")

#n <- length(sigLRT_genes)

#rld <- rlog(dds, blind=TRUE)
#rld_mat <- assay(rld) %>%
  #as.matrix()

#all(rownames(coldataLRT) == colnames(rld_mat))

# Subset results for faster cluster finding
#clustering_sig_genes <- sig_res_LRT %>%
                 #arrange(padj) %>%
                  #head(n=n)

# Obtain rlog values for those significant genes
#cluster_rlog <- rld_mat[clustering_sig_genes$gene, ]

# this function runs for a long time depending on n
#clusters <- degPatterns(cluster_rlog, metadata = coldataLRT, time = "Agecat", col=NULL)
saveRDS(clusters, "Ageing/Clusters/Clusters.rds")

clusters <- readRDS("Ageing/Clusters/Clusters.rds")

level_order <- c("18-29", "30-39", "40-49", "50-59", "60-69", "70-80")

# Plot all clusters  
timeSeries <- degPlotCluster(clusters$normalized, time = "Agecat", lines = F) +
  scale_x_discrete(limits = level_order) +
  scale_color_manual(values = "#2e008b") +
 # facet_wrap(~factor(clusters$plot$data$title,
 #                   levels = as.list(unique(clusters$plot$data$title))),
 #          ncol = 2) +
  theme_linedraw(base_size = 16) +
    labs(title = "Gene clusters exhibiting particular patterns across age",
         subtitle = "",
         x = "Age group (years)",
         y = "Z-score of gene abundance") +
    theme(plot.title=element_text(hjust=0.5, size = 18),
          plot.subtitle=element_text(hjust=0.5),
          axis.title.x     = element_text(size = 18),
          axis.title.y     = element_text(size = 18),
          panel.grid.major = element_line(colour = "lightgrey"),
          panel.grid.minor = element_line(colour = "lightgrey"),
          legend.position = "none"
    )

timeSeries

ggsave("Ageing/Clusters/All_clusters.png", 
       plot = timeSeries, 
       width = 24, height = 15, dpi = 300)

```

### Pathway enrichment

**NOTE:** ORA is performed using clusterProfiler. "Universe" is set to all genes from the filtered counts matrix. Minimum gene set = 5 and max is set to 2000 to accommodate the large clusters. padjusted values for ORA is calculated using the BH method with the threshold set to < 0.05 and q-value from clusterProfiler is set to 0.2 (unchanged from the original function).

Some clusters did not pass the threshold values for ORA so they are excluded from the plots.

#### Reactome

```{r eval=FALSE, fig.height=5, fig.width=6, include=FALSE}
reactome <- msigdbr(species = "Homo sapiens",
                 category = "C2", subcategory = "CP:REACTOME") %>%
  dplyr::distinct(gs_name, ensembl_gene) %>%
  mutate(gs_name = gsub("REACTOME_", "", gs_name)) %>%
  mutate(gs_name = gsub("_", " ", gs_name))

universe <- deResults_list %>%
  .[[1]] %>% rownames(.)

cl_num <- c(unique(clusters$df$cluster))

enriched_plots <- list()
enriched_lrt <- list()

for (i in cl_num) {
  C1_names <- clusters$df %>%
  filter(cluster == i) %>%
  pull(genes)

options(enrichment_force_universe = TRUE)

#print(i)

C1_Enrich <- enricher(gene = C1_names,
                      pvalueCutoff = 0.05,
                      pAdjustMethod = "BH",
                      universe = universe,
                      minGSSize = 5,
                      maxGSSize = 2000,
                      qvalueCutoff = 0.2,
                      gson = NULL,
                      TERM2GENE = reactome,
                      TERM2NAME = NA)

if (!is.null(C1_Enrich)) {
  C1_Enrich_plot <- barplot(C1_Enrich, showCategory = 20) +
  labs(title = paste0("Cluster ", i, " (pvalue < 0.05)")) +
  theme_cowplot() +
  theme(plot.title=element_text(hjust=0.5),
          plot.subtitle=element_text(hjust=0.5),
          axis.title.y = element_text(size=15, face="italic"),
          panel.grid.minor = element_blank())
 
      if (nrow(C1_Enrich_plot$data) > 0) {
        enriched_lrt[[paste0("barPlot_cluster_", i)]] <- C1_Enrich
      enriched_plots[[paste0("barPlot_cluster_", i)]] <- C1_Enrich_plot
      } else {
        enriched_lrt[[paste0("barPlot_cluster_", i)]] <- C1_Enrich
      }
 
} else {
  enriched_lrt[[paste0("barPlot_cluster_", i)]] <- C1_Enrich
}

}

pdf(file = "Ageing/Clusters/Pathway_Enrichment_Reactome.pdf",  
    width =8.5, # The width of the plot in inches
    height = 10) # The height of the plot in inches

enriched_plots

dev.off()

enriched_plots

```

### Selected

#### Clusters

```{r}
# Define and filter your clusters
selected_clusters <- c(3, 4, 6, 7, 13, 15, 16, 20)

clusters_sel           <- clusters
clusters_sel$normalized <- clusters$normalized %>%
  filter(cluster %in% selected_clusters)
clusters_sel$df         <- clusters$df %>%
  filter(cluster %in% selected_clusters)

# Compute gene counts per cluster
cluster_counts <- clusters_sel$df %>%
  count(cluster) %>%
  arrange(cluster)

# Build a named vector of labels, e.g. "Cluster 3 (123 genes)"
cluster_labels <- setNames(
  paste0("Cluster ", cluster_counts$cluster, "\n(", cluster_counts$n, " genes)"),
  cluster_counts$cluster
)

# Plot with facet_wrap + custom labeller
select <- degPlotCluster(
       clusters_sel$normalized,
       time  = "Agecat",
       lines = FALSE,
       smooth = FALSE,
     ) +
  scale_color_manual(values = "#2e008b") +
     facet_wrap(
       ~ cluster,
       nrow    = 4,
       ncol    = 2,
       scales  = "free_y",
       labeller = labeller(cluster = cluster_labels)
     ) +
     labs(
       title = "Gene clusters exhibiting particular patterns across age",
       x = "Age group (years)"
     ) +
     theme_linedraw(base_size = 14) +
     theme(
       plot.title      = element_text(hjust = 0.5, size = 20),
       axis.title.x     = element_text(size = 18),
       strip.text      = element_text(size = 16),
       axis.text.y      = element_text(size =  16, color = "black"),
       axis.text.x      = element_text(size =  16, color = "black"),
       legend.position = "none"
     ) 

ggsave("Ageing/Clusters/Selected_Clusters.png",
       plot = select, width = 8, height = 12, dpi = 300)

select

```

#### Reactome

```{r}
selected_clusters <- c(3, 4, 6, 7, 13, 15, 16, 20)

reactome <- msigdbr(
  species     = "Homo sapiens",
  category    = "C2",
  subcategory = "CP:REACTOME"
) %>%
  distinct(gs_name, ensembl_gene) %>%
  mutate(
    gs_name = gsub("REACTOME_", "", gs_name),
    gs_name = gsub("_", " ", gs_name)
  )

universe <- rownames(cts_filtered)
barplots <- list()

for (i in selected_clusters) {
  genes_in_cluster <- clusters$df %>%
    filter(cluster == i) %>%
    pull(genes)
  
  C1_Enrich <- enricher(
    gene          = genes_in_cluster,
    universe      = universe,
    TERM2GENE     = reactome,
    pvalueCutoff  = 0.05,
    pAdjustMethod = "BH",
    minGSSize     = 5,
    maxGSSize     = 2000,
    qvalueCutoff  = 0.2
  )
  
  if (!is.null(C1_Enrich) && nrow(C1_Enrich@result) > 0) {
    dp <- barplot(
      C1_Enrich,
      showCategory = 5          # only top 5 terms
    ) +
      labs(
        title    = paste0("Cluster ", i),
        subtitle = NULL,
        x = "Gene ratio"
      ) +
      theme_minimal(base_size = 20) +  # smaller base font
      theme(
        plot.title       = element_text(hjust = 0.5, size = 16, color = "black", face = "bold"),
        plot.subtitle    = element_text(hjust = 0.5, size =  15, color = "black"),
        axis.text.y      = element_text(size =  10, color = "black"),
        axis.text.x      = element_text(size =  12, color = "black"),
        axis.title.x     = element_text(size = 14),   
        axis.title.y     = element_blank(),
        legend.title     = element_text(size =  20, color = "black"),
        legend.text      = element_text(size =  20, color = "black"),
        plot.margin      = margin(4, 4, 4, 4, "mm")
      )
    
    barplots[[paste0("C", i)]] <- dp
  }
}

shared_legend <- get_legend(
  barplot(C1_Enrich, showCategory = 5) +
    theme_minimal() +
    theme(
      legend.direction   = "vertical",
      legend.title       = element_text(size = 16),
      legend.text        = element_text(size = 14),
      legend.key.height  = unit(4, "mm")
    )
)

# Strip legends from all the plots
plots_no_legend <- lapply(barplots, function(p) 
  p + theme(legend.position = "none")
)

# Build the 4×2 grid of plots
plots_grid <- plot_grid(
  plotlist = plots_no_legend,
  ncol     = 2,
  align    = "hv",
  labels     = LETTERS[2:9],     # adds A, B, C ... H
  label_size = 20,
  label_fontface = "bold"
)

# Combine the grid and shared legend
select_ora <- plot_grid(
  plots_grid,        # left (8 panels)
  shared_legend,     # right (single legend)
  ncol       = 2,
  rel_widths = c(0.9, 0.1)   # adjust as needed
)

# Save as a compact A4‐style PNG
ggsave(
  "Ageing/Clusters/Selected_Clusters_Enrichment.png",
  select_ora,
  width  = 13,    
  height = 15,   
  dpi    = 300,
  units  = "in",
  bg = "white"
)
```
#### Merge figures

```{r}
# First, create your individual plots with labels
plot_A <- select + 
  ggtitle("Gene cluster patterns") +
  theme(
  plot.title = element_text(size = 20, face = "bold")
)

plot_B <- select_ora

# Method 1: Save individual plots with cowplot labels
plot_A_labeled <- plot_grid(
  plot_A, 
  labels = "A", 
  label_size = 20,
  ncol = 1
)

# Save individual plots
ggsave("Ageing/Clusters/Selected_Clusters.png", 
       plot = plot_A_labeled, 
       width = 10, height = 15, dpi = 300)

ggsave("Ageing/Clusters/Selected_Clusters_Enrichment.png", 
       plot = plot_B, 
       width = 13, height = 15, dpi = 300, bg = "white")

# Read the saved images
img_A <- image_read("Ageing/Clusters/Selected_Clusters.png")
img_B <- image_read("Ageing/Clusters/Selected_Clusters_Enrichment.png")

# Combine side by side
combined_image <- image_append(c(img_A, img_B), stack = FALSE)

# Save the combined image
image_write(combined_image, "Ageing/Clusters/Combined_Figure.png")
```

#### GO

```{r}
selected_clusters <- c(3, 4, 6, 7, 13, 15, 16, 20)

# Define the universe as background (your DE genes)
universe <- all_gene_ensembl
dotplots <- list()

for (i in selected_clusters) {
  genes_in_cluster <- clusters$df %>%
    filter(cluster == i) %>%
    pull(genes)

  # GO Biological Process enrichment using enrichGO
  C1_Enrich <- enrichGO(
    gene          = genes_in_cluster,
    universe      = universe,
    OrgDb         = org.Hs.eg.db,
    keyType       = "ENSEMBL",
    ont           = "BP",
    pvalueCutoff  = 0.05,
    pAdjustMethod = "BH",
    qvalueCutoff  = 0.2,
    readable      = TRUE
  )

  if (!is.null(C1_Enrich) && nrow(C1_Enrich@result) > 0) {
    dp <- dotplot(
      C1_Enrich,
      showCategory = 5
    ) +
      labs(
        title    = paste0("Cluster ", i),
        subtitle = sprintf("n = %d genes", length(genes_in_cluster))
      ) +
      theme_minimal(base_size = 20) +
      theme(
        plot.title       = element_text(hjust = 0.5, size = 16, color = "black"),
        plot.subtitle    = element_text(hjust = 0.5, size = 12, color = "black"),
        axis.text.y      = element_text(size = 10, color = "black"),
        axis.text.x      = element_text(size = 10, color = "black"),
        axis.title       = element_blank(),
        legend.title     = element_text(size = 10, color = "black"),
        legend.text      = element_text(size = 10, color = "black"),
        plot.margin      = margin(4, 4, 4, 4, "mm")
      )

    dotplots[[paste0("C", i)]] <- dp
  }
}

# Shared legend from one plot (e.g. first that exists)
shared_legend <- get_legend(
  dotplots[[1]] +
    theme(
      legend.direction   = "vertical",
      legend.title       = element_text(size = 10),
      legend.text        = element_text(size = 8),
      legend.key.height  = unit(4, "mm")
    )
)

# Remove legends from each plot
plots_no_legend <- lapply(dotplots, function(p)
  p + theme(legend.position = "none")
)

# 4×2 grid of cluster plots
plots_grid <- plot_grid(
  plotlist      = plots_no_legend,
  ncol          = 2,
  align         = "hv",
  labels        = LETTERS[1:length(plots_no_legend)],
  label_size    = 14,
  label_fontface = "bold"
)

# Combine plot grid with legend
final_plot <- plot_grid(
  plots_grid,
  shared_legend,
  ncol        = 2,
  rel_widths  = c(0.9, 0.1)
)

# Save final PNG
ggsave(
  "Ageing/Clusters/Selected_Clusters_GO_BP_Enrichment.png",
  final_plot,
  width  = 13,
  height = 13.5,
  dpi    = 300,
  units  = "in",
  bg     = "white"
)
```


### ESR1 pathways

```{r}
# Get Ensembl ID for ESR1
esr1_ensembl <- AnnotationDbi::select(org.Hs.eg.db,
                                      keys = "ESR1",
                                      keytype = "SYMBOL",
                                      columns = "ENSEMBL")$ENSEMBL

# Filter Reactome pathways that include ESR1
esr1_pathways <- reactome %>%
  filter(ensembl_gene %in% esr1_ensembl) %>%
  distinct(gs_name)

# View top results
length(esr1_pathways)
write.csv(esr1_pathways, "Ageing/ESR1/ESR1_pathways.csv")

esr1_enriched_clusters <- lapply(names(enriched_lrt), function(cluster_name) {
  enrichment <- enriched_lrt[[cluster_name]]
  
  if (!is.null(enrichment) && "Description" %in% colnames(enrichment@result)) {
    enriched_paths <- enrichment@result %>%
      filter(Description %in% esr1_pathways$gs_name)
    
    if (nrow(enriched_paths) > 0) {
      enriched_paths$cluster <- cluster_name
      return(enriched_paths)
    }
  }
  return(NULL)
}) %>% bind_rows()

write.csv(esr1_enriched_clusters, "Ageing/ESR1/ESR1_enriched_clusters.csv")

# How does ESR1 change across age groups?

esr1_rlog <- assay(rld)[esr1_ensembl, , drop = FALSE] %>%
  t() %>%
  as.data.frame()
esr1_rlog$Agecat <- coldataLRT$Agecat
colnames(esr1_rlog)[1] <- "expression"
esr1_rlog$Sample <- rownames(esr1_rlog)

colnames(esr1_rlog)[1] <- "expression"

# Plot ESR1 expression by Agecat
ESR1_agecat <- ggplot(esr1_rlog, aes(x = Agecat, y = expression)) +
  geom_boxplot(fill = "#2e008b", alpha = 0.7) +
  geom_jitter(width = 0.1, alpha = 0.4) +
  scale_x_discrete(limits = level_order) +
  theme_classic(base_size = 16) +
  labs(title = "ESR1 expression across age groups", y = "rlog expression")

pdf("Ageing/ESR1/ESR1_Age.pdf",
    width = 6,
    height = 5)
ESR1_agecat
dev.off()

# Which cluster is ESR1 in?

esr1_cluster <- clusters$df %>% filter(genes == "ESR1")
print(esr1_cluster)


```

# Hormone Analysis*

## Associations

Results are exported into two csv files - all expressed genes and only significant genes. 

```{r}

# Specify the columns to scale
vars_to_scale <- c("E2", "FEI", "TT", "FAI", "Prog")

# Scale and convert to data frame
scaled_data <- as.data.frame(scale(pheno_data[vars_to_scale], center = TRUE, scale = TRUE))

# Rename columns to add "_z" suffix
names(scaled_data) <- paste0(vars_to_scale, "_z")

# Combine scaled columns with original data
pheno_scaled <- cbind(pheno_data, scaled_data)

# Keep only samples with non-missing FEI_z
keep_samples <- !is.na(pheno_scaled$FEI_z)

# Subset phenotype and count data
pheno_subset <- pheno_scaled[keep_samples, ]
cts_subset <- cts[, keep_samples]

keep_genes <- rowMeans(cts_subset) >= 10
cts_filtered <- cts_subset[keep_genes, ]

cat("Genes retained after low-count filtering:", sum(keep_genes), 
    "out of", nrow(cts_subset), "\n")

# Create base DESeq object once
dds_base <- DESeqDataSetFromMatrix(
  countData = cts_filtered, 
  colData = pheno_subset, 
  design = ~ 1  # Temporary design
)

# Estimate size factors once
dds_base <- estimateSizeFactors(dds_base)

# Get normalized counts for quality control
vsd <- vst(dds_base, blind = FALSE)

# Pre-map gene names once
ensembl_ids <- rownames(cts_filtered)
gene_names <- mapIds(
  org.Hs.eg.db,
  keys = ensembl_ids,
  column = "SYMBOL",
  keytype = "ENSEMBL",
  multiVals = "first"
)

predictors <- c("E2_z", "FEI_z", "TT_z", "FAI_z", "Prog_z")

var_labels <- c(
  E2_z = "E2",
  FEI_z = "Free E2 Index",
  TT_z = "Testosterone",
  FAI_z = "Free Androgen Index",
  Prog_z = "Progesterone"
)

dds_results_list <- list()

for (var in predictors) {
  cat("Processing", var, "...\n")

  design_formula <- as.formula(paste("~ Batch + ", var, " + Age"))
  design(dds_base) <- design_formula

dds <- DESeq(dds_base, quiet = TRUE)

# Extract results
res <- results(dds, name = var)
res_df <- as.data.frame(res)
res_df$ensembl_id <- rownames(res_df)
  
res_df$gene_name <- mapIds(
    org.Hs.eg.db,
    keys = res_df$ensembl_id,
    column = "SYMBOL",
    keytype = "ENSEMBL",
    multiVals = "first"
  )
  
  # Save all results
  sanitized_name <- gsub("[^a-zA-Z0-9_]", "_", var)
  write.csv(res_df, paste0("Hormones/Results/All Genes/DE_results_all_", sanitized_name, ".csv"), row.names = FALSE)
  
  # Save significant only
  sig_df <- subset(res_df, padj < 0.05)
  write.csv(sig_df, paste0("Hormones/Results/Significant Genes/DE_results_sig_", sanitized_name, ".csv"), row.names = FALSE)
  
  # Save in list
  dds_results_list[[var]] <- res_df
  
}

# Create summary table
summary_df <- data.frame(
  Hormone = predictors,
  Total_Genes = sapply(dds_results_list, nrow),
  Significant_Genes = sapply(dds_results_list, function(x) sum(x$padj < 0.05, na.rm = TRUE)),
  Upregulated = sapply(dds_results_list, function(x) sum(x$padj < 0.05 & x$log2FoldChange > 0, na.rm = TRUE)),
  Downregulated = sapply(dds_results_list, function(x) sum(x$padj < 0.05 & x$log2FoldChange < 0, na.rm = TRUE))
)

write.csv(summary_df, "Hormones/Results/Adjusted_Analysis_Summary.csv", row.names = FALSE)
print(summary_df)

# Save RDS with results

saveRDS(dds_results_list, "Hormones/Results/Adjusted_Hormone_associations_res.rds")

```

## Hormone plots

```{r}

dds_results_list <- readRDS("Hormones/Results/Hormone_associations_res.rds")

predictors <- c("E2_z", "FEI_z", "TT_z", "FAI_z", "Prog_z")

var_labels <- c(
  E2_z  = "E2",
  FEI_z = "Free E2 Index",
  TT_z  = "Testosterone",
  FAI_z = "Free Androgen Index",
  Prog_z = "Progesterone"
)


plot_list <- list()

for (var in predictors) {
  
  res_df <- dds_results_list[[var]]
  
   # Count significant genes based on p-value cutoff
  sig_genes <- sum(res_df$padj < 0.05, na.rm = TRUE)
  
  # Get maximum absolute fold-change for xlim setting
  max_abs_fc <- max(abs(res_df$log2FoldChange), na.rm = TRUE)
  
  # Get maximum –log10(padj)
  max_y <- max(-log10(res_df$padj), na.rm=TRUE)
  break_low  <- 6 # Everything above this is the gap
  break_high <- max_y - 1 # This is where to end the break
  
  # Get gene labels for significant genes
  lab_vec <- ifelse(
  !is.na(res_df$padj) & res_df$padj < 0.05,
  ifelse(res_df$gene_name != "" & !is.na(res_df$gene_name), res_df$gene_name,   res_df$ensembl_id),
  ""  # Leave blank if not significant
)
  
# EnhancedVolcano plot (focused on p-value significance only)
  
num_up   <- sum(res_df$padj < 0.05 & res_df$log2FoldChange > 0, na.rm = TRUE)
num_down <- sum(res_df$padj < 0.05 & res_df$log2FoldChange < 0, na.rm = TRUE)
  
  keyvals <- ifelse(
  res_df$padj < 0.05 & res_df$log2FoldChange > 0, "red",
  ifelse(res_df$padj < 0.05 & res_df$log2FoldChange < 0, "blue", "darkgrey")
)

# Force replace any NA colors with default
keyvals[is.na(keyvals)] <- "darkgrey"

# Assign labels only where color is valid (lengths must match!)
keyval_labels <- ifelse(
  keyvals == "red", paste0("Up (n=", num_up,")"),
  ifelse(keyvals == "blue", paste0("Down (n=", num_down, ")"), 
         ifelse(keyvals == "darkgrey", "NS", NA))
)

# Assign names explicitly — this ensures no `NA` legend keys are created
names(keyvals) <- keyval_labels

# Final check to remove any names that are NA
keyvals <- keyvals[!is.na(names(keyvals))]
  
  p <- EnhancedVolcano(res_df, 
                               x = "log2FoldChange", 
                               y = "padj", 
                               lab = lab_vec, 
                               labSize = 3.5,
                               max.overlaps = Inf,            # allow unlimited labels
                               drawConnectors = TRUE,         # optional: draws lines back to points
                               widthConnectors = 0.5,         # thinner connector lines
                               pCutoff = 0.05,  
                               FCcutoff = 0,
                               ylim = c(0, max_y * 1), # change to c(0, 15) for even y axes
                               gridlines.major = FALSE, 
                               gridlines.minor = FALSE,
                               title = paste(var_labels[[var]]), 
                               subtitle = NULL,
                               caption = NULL,
                               xlim = c(-max_abs_fc, max_abs_fc),# Centers at 0 
                               colCustom = keyvals,
                               legendPosition = "top"
  ) +
    theme(
    axis.text     = element_text(color = "black"),  # tick labels
    axis.title    = element_text(color = "black"),  # axis titles
    plot.title    = element_text(color = "black"),  # main title
    plot.subtitle = element_text(color = "black")   # subtitle
  )
  
  ggsave(
    filename = file.path("Hormones/Figures/", paste0("Volcano_", var_labels[[var]], ".png")),
    plot     = p,
    width    = 6, height = 5, dpi = 300
  )
  
  plot_list[[var]] <- p
  
}

combined <- wrap_plots(plot_list, ncol = 3) +
  plot_annotation(tag_levels = 'A') & 
  theme(plot.tag = element_text(size = 20, face = "bold"))
  
  ggsave(
    filename = file.path("Hormones/Figures/All_Volcano_plots.png"),
    plot     = combined,
    width    = 15, height = 12, dpi = 300
  )
  
```

# Receptor Analysis

## BED files

UniBind requires a BED file for genes of interest (age associated genes) and background genes (all genes).

```{r}
# ───────────────────────────────────────────────────────────────────────────────
# 1) BUILD HG38 PROMOTER WINDOWS (–2 kb to +200 bp around TSS)
# ───────────────────────────────────────────────────────────────────────────────
ah   <- AnnotationHub()
txdb <- ah[["AH117076"]]        # hg38 TxDb (RefSeq)
gr   <- genes(txdb)             # GRanges of all hg38 genes

# 1a) Map Entrez → SYMBOL
entrez_ids <- mcols(gr)$gene_id
symbols    <- mapIds(
  org.Hs.eg.db,
  keys      = as.character(entrez_ids),
  column    = "SYMBOL",
  keytype   = "ENTREZID",
  multiVals = "first"
)
mcols(gr)$symbol <- symbols

# 1b) Compute promoter windows: –2000 to +200 bp from TSS
promoter_windows <- as.data.frame(gr) %>%
  transmute(
    chr    = as.character(seqnames),
    strand = as.character(strand),
    tss    = ifelse(strand == "+", start, end),
    win_start = ifelse(strand == "+", pmax(0, tss - 2000), pmax(0, tss - 200)),
    win_end   = ifelse(strand == "+", tss + 200,               tss + 2000),
    name  = symbol
  ) %>%
  transmute(chr, start = win_start, end = win_end, name)

# 1c) Keep only standard chromosomes (chr1–22, chrX, chrY) and valid symbols
standard_chrs   <- paste0("chr", c(1:22, "X", "Y"))
promoter_windows <- promoter_windows %>%
  filter(chr %in% standard_chrs, !is.na(name), name != "")

# ───────────────────────────────────────────────────────────────────────────────
# 2) DEFINE make_bed() FOR WRITING 4‐COLUMN BEDs
# ───────────────────────────────────────────────────────────────────────────────
make_bed <- function(hits, filename) {
  # 'hits' is a character vector of gene symbols
  bed <- promoter_windows %>%
    filter(name %in% hits) %>%
    select(chr, start, end, name)
  if (nrow(bed) == 0) {
    message("⚠️  No rows to write for ", filename, " (skipped)")
    return(NULL)
  }
  write.table(
    bed,
    file      = filename,
    sep       = "\t",
    quote     = FALSE,
    col.names = FALSE,
    row.names = FALSE,
    eol       = "\n"
  )
}

# ───────────────────────────────────────────────────────────────────────────────
# 3) “STATIC” GENE SETS: FULL‐LIST BEDS (USING PROMOTER WINDOWS)
# ───────────────────────────────────────────────────────────────────────────────

# 3a) All genes (symbols from RDS)
bg_df   <- readRDS("Ageing/All_genes.rds")      # each element is a gene symbol
bg_hits <- unique(na.omit(bg_df))
make_bed(bg_hits, "TF Analysis/All_genes.bed")

# 3b) Age‐associated genes (symbols from RDS)
age_df   <- readRDS("Ageing/Age_associated_genes.rds")
age_hits <- unique(na.omit(age_df))
make_bed(age_hits, "TF Analysis/Age_associated_genes.bed")

# 3c) Background set: ages 18–30 & 60–80 combined
pheno_agebg <- pheno_data %>%
  filter(!Agecat %in% c("30-39", "40-49", "50-59"))
rownames(pheno_agebg) <- pheno_agebg$ColName
cts_agebg <- cts[, rownames(pheno_agebg)]

agebg_genes   <- rownames(cts_agebg)  # ENSEMBL IDs
agebg_symbols <- mapIds(
  org.Hs.eg.db,
  keys      = agebg_genes,
  column    = "SYMBOL",
  keytype   = "ENSEMBL",
  multiVals = "first"
)
agebg_hits    <- unique(na.omit(agebg_symbols))
make_bed(agebg_hits, "TF Analysis/Agecat_bg_genes.bed")

# 3d) DE genes for each hormone (from dds_results_list)
hormones <- c("E2_z", "FEI_z", "TT_z", "FAI_z", "Prog_z")
for (hormone in hormones) {
  res_df     <- dds_results_list[[hormone]]
  sig_genes  <- rownames(res_df)[!is.na(res_df$padj) & res_df$padj < 0.05]
  sig_symbols <- mapIds(
    org.Hs.eg.db,
    keys      = sig_genes,
    column    = "SYMBOL",
    keytype   = "ENSEMBL",
    multiVals = "first"
  )
  bed_path <- paste0("TF Analysis/DEsig_", hormone, "_genes.bed")
  make_bed(unique(na.omit(sig_symbols)), bed_path)
}

# ───────────────────────────────────────────────────────────────────────────────
# 5) DESeq2 WORKFLOW: PREMENOPAUSAL vs POSTMENOPAUSAL
# ───────────────────────────────────────────────────────────────────────────────

# 5a) Subset pheno_data to Premenopausal & Postmenopausal only, re‐level
pheno_meno <- pheno_data %>%
  filter(Menopause %in% c("Premenopausal", "Postmenopausal")) %>%
  mutate(Menopause = factor(Menopause, levels = c("Postmenopausal", "Premenopausal")))
rownames(pheno_meno) <- pheno_meno$ColName

# 5b) Subset counts to those samples
cts_meno <- cts[, rownames(pheno_meno)]

# 5c) Build DESeqDataSet (adjust for Batch & Menopause)
dds_meno <- DESeqDataSetFromMatrix(
  countData = cts_meno,
  colData   = pheno_meno,
  design    = ~ Batch + Menopause
)

# 5d) Prefilter: keep only genes with sum(counts) ≥ 10
keep_meno <- rowSums(counts(dds_meno)) >= 10
dds_meno <- dds_meno[keep_meno, ]

# 5e) Run DESeq normalization & testing
dds_meno <- DESeq(dds_meno)

# 5f) Extract results for Premenopausal vs Postmenopausal
res_meno      <- results(dds_meno, contrast = c("Menopause", "Premenopausal", "Postmenopausal"))

# Significant DE genes
res_sig_meno <- res_meno[!is.na(res_meno$padj) & res_meno$padj < 0.05, ]

# Genes up in Premenopausal
up_pre <- res_sig_meno[res_sig_meno$log2FoldChange > 0, ]
up_pre_syms <- mapIds(
  org.Hs.eg.db,
  keys      = rownames(up_pre),
  column    = "SYMBOL",
  keytype   = "ENSEMBL",
  multiVals = "first"
) %>% unique() %>% na.omit()

# Genes up in Postmenopausal
up_post <- res_sig_meno[res_sig_meno$log2FoldChange < 0, ]
up_post_syms <- mapIds(
  org.Hs.eg.db,
  keys      = rownames(up_post),
  column    = "SYMBOL",
  keytype   = "ENSEMBL",
  multiVals = "first"
) %>% unique() %>% na.omit()

# Save BEDs
make_bed(up_pre_syms,  "TF Analysis/DEG_Premenopausal_promoters.bed")
make_bed(up_post_syms, "TF Analysis/DEG_Postmenopausal_promoters.bed")

# ───────────────────────────────────────────────────────────────────────────────
# 6) DESeq2 WORKFLOW: AGE 18–30 vs AGE 60–80
# ───────────────────────────────────────────────────────────────────────────────

pheno_age_filt <- pheno_data %>%
  filter(!is.na(Age), Age <= 30 | Age >= 60) %>%
  mutate(AgeGroup = ifelse(Age <= 30, "Young18_30", "Old60_80")) %>%
  mutate(AgeGroup = factor(AgeGroup, levels = c("Old60_80", "Young18_30")))
rownames(pheno_age_filt) <- pheno_age_filt$ColName

# 6b) Subset counts to those samples
cts_age_filt <- cts[, rownames(pheno_age_filt)]

# 6c) Build DESeqDataSet for AgeGroup
dds_age <- DESeqDataSetFromMatrix(
  countData = cts_age_filt,
  colData   = pheno_age_filt,
  design    = ~ Batch + AgeGroup
)

# 6d) Prefilter: sum(counts) ≥ 10
keep_age <- rowSums(counts(dds_age)) >= 10
dds_age <- dds_age[keep_age, ]

# 6e) Run DESeq
dds_age <- DESeq(dds_age)

# 6f) Extract results: Young18_30 vs Old60_80
res_age      <- results(dds_age, contrast = c("AgeGroup", "Young18_30", "Old60_80"))

# Significant DE genes
res_sig_age <- res_age[!is.na(res_age$padj) & res_age$padj < 0.05, ]

# Up in young
up_young <- res_sig_age[res_sig_age$log2FoldChange > 0, ]
up_young_syms <- mapIds(
  org.Hs.eg.db,
  keys      = rownames(up_young),
  column    = "SYMBOL",
  keytype   = "ENSEMBL",
  multiVals = "first"
) %>% unique() %>% na.omit()

# Up in old
up_old <- res_sig_age[res_sig_age$log2FoldChange < 0, ]
up_old_syms <- mapIds(
  org.Hs.eg.db,
  keys      = rownames(up_old),
  column    = "SYMBOL",
  keytype   = "ENSEMBL",
  multiVals = "first"
) %>% unique() %>% na.omit()

# Save BEDs
make_bed(up_young_syms, "TF Analysis/DEG_Young_promoters.bed")
make_bed(up_old_syms,   "TF Analysis/DEG_Old_promoters.bed")


```
## Figure

```{r}
library(magick)

library(magick)

# Helper: create combined label + title banner
make_labelled_title <- function(label, title_text, width, height = 60) {
  img <- image_blank(width = width, height = height, color = "white")
  img <- image_annotate(
    img,
    text = paste0(label),  # e.g., A.
    gravity = "west",
    location = "+20+10",
    size = 20,
    weight = 700
  )
  img <- image_annotate(
    img,
    text = title_text,
    gravity = "west",
    location = "+70+10",  # shift to the right of the label
    size = 16,
    weight = 700
  )
  return(img)
}

# Read images from your folder
img_A <- image_read("TF Analysis/Figure/Pre_allEnrichments_swarm.png.png")
img_B <- image_read("TF Analysis/Figure/Post_allEnrichments_swarm.png.png")

# Standardize width
standard_width <- min(image_info(img_A)$width,
                      image_info(img_B)$width)

# Compose one plot panel
compose_panel <- function(img, label, title_text) {
  img <- image_resize(img, paste0(standard_width, "x"))
  title_bar <- make_labelled_title(label, title_text, width = image_info(img)$width)
  image_append(c(title_bar, img), stack = TRUE)
}

# Build each panel
panel_A <- compose_panel(img_A, "A", "Enriched in premenopausal females")
panel_B <- compose_panel(img_B, "B", "Enriched in postmenopausal females")

# Combine panels into 2x2 layout
final_figure <- image_append(c(panel_A, panel_B), stack = FALSE)

# Save result
image_write(final_figure, "TF Analysis/Swarm_Combined.png")


```

## Significant enrichment

```{r}
file_paths <- list(
  old   = "TF Analysis/TSV/allEnrichments_old.tsv",
  post  = "TF Analysis/TSV/allEnrichments_post.tsv",
  pre   = "TF Analysis/TSV/allEnrichments_pre.tsv",
  young = "TF Analysis/TSV/allEnrichments_young.tsv"
)

# Function to return list of unique significant antibodies
get_unique_antibodies <- function(path) {
  read_tsv(path, show_col_types = FALSE) %>%
    filter(pValueLog > 2, !is.na(antibody), antibody != "") %>%
    distinct(antibody) %>%
    pull(antibody)
}

# Get TF lists
tf_lists <- lapply(file_paths, get_unique_antibodies)

# Get counts from the same lists
tf_counts <- sapply(tf_lists, length)

# Create summary table
summary_df <- data.frame(
  Group = names(tf_counts),
  Unique_Significant_TFs = tf_counts
)

# Show summary
print(summary_df)

# View actual TFs per group
tf_lists$post 
tf_lists$pre
tf_lists$young
tf_lists$old

```


## TF Binding sites

This analysis shows us what proportion of age-associated genes have the ER and PGR binding sites. 

67% of age related genes have the ESR1 binding site.
99.8% of age related genes have the PGR binding site.
100% of age related genes have the AR binding site.

```{r load-deseq-results}
# Load Gene list - This can be significant DE genes, or any gene list of interest. Here I will select nonlinear genes
ensembl_gene_id <- readRDS("Data/all_sig_genes.rds") 

# Use biomaRt to get promoter regions
mart <- useEnsembl("ensembl", dataset = "hsapiens_gene_ensembl")

# Get gene coordinates and TSS
gene_annot <- getBM(attributes = c("ensembl_gene_id", "chromosome_name", 
                                   "start_position", "end_position", 
                                   "strand", "external_gene_name"),
                    filters = "ensembl_gene_id",
                    values = ensembl_gene_id,
                    mart = mart)

valid.chr <- c(as.character(1:22), "X", "Y", "MT")
gene_annot <- gene_annot %>%
  filter(chromosome_name %in% valid.chr)


promoters <- gene_annot %>%
  mutate(
    prom_start = ifelse(strand == 1,
                        start_position - 2000,
                        end_position   - 200),
    prom_end   = ifelse(strand == 1,
                        start_position +  200,
                        end_position   +2000),
    chrom = paste0("chr", chromosome_name)
  ) %>%
  dplyr::select(chrom, prom_start, prom_end, ensembl_gene_id)


# Convert to GRanges
gr_promoters <- GRanges(
  seqnames = promoters$chrom,
  ranges   = IRanges(start = promoters$prom_start,
                     end   = promoters$prom_end),
  gene_id  = promoters$ensembl_gene_id
)

# enforce UCSC naming/style and drop any stray contigs
seqlevelsStyle(gr_promoters) <- "UCSC"
gr_promoters <- keepStandardChromosomes(gr_promoters,
                                        pruning.mode = "coarse")
# (now only chr1–22, X, Y, M remain)

# Extract DNA sequences
promoter_seqs <- getSeq(BSgenome.Hsapiens.UCSC.hg38,
                        gr_promoters)

names(promoter_seqs) <- gr_promoters$gene_id

# Get hormone receptor motifs from JASPAR2024

jaspar <- JASPAR2024()
sq24 <- RSQLite::dbConnect(RSQLite::SQLite(), db(jaspar))
motifs <- TFBSTools::getMatrixSet(sq24, list(species = "Homo sapiens", all_versions = TRUE))

# Check the TF names of the motifs
motif_names <- sapply(motifs, name)

# Filter by TF name
esr1_motifs <- motifs[sapply(motifs, name) == "ESR1"]
ar_motifs   <- motifs[sapply(motifs, name) == "AR"]
pgr_motifs <- motifs[sapply(motifs, name) == "PGR"]
length(esr1_motifs)
length(ar_motifs)
length(pgr_motifs)

# Convert to PWM
motifs_esr_pwm <- toPWM(esr1_motifs[[1]])
motifs_pgr_pwm <- toPWM(pgr_motifs[[1]])
motifs_ar_pwm <- toPWM(ar_motifs[[1]])
pwmList <- PWMatrixList(ESR1 = motifs_esr_pwm, PGR = motifs_pgr_pwm, AR = motifs_ar_pwm)

# Function to scan one motif across all promoters
scan_motif_hits <- function(pwm, sequences, threshold = 0.8) {
  hits <- lapply(names(sequences), function(gene) {
    seq <- sequences[[gene]]
    sites <- TFBSTools::searchSeq(pwm, seq, strand="*",
                       min.score=paste0(threshold*100, "%"))
    data.frame(gene_id = gene, n_sites = length(sites))
  })
  bind_rows(hits)
}

# Scan promotor sequences for each motif
scan_results <- lapply(pwmList, scan_motif_hits, sequences = promoter_seqs)

# Combine results
combined_hits <- bind_rows(scan_results, .id = "TF")

# Count how many promoters contain each motif
summary_df <- combined_hits %>%
  group_by(TF) %>%
  summarise(n_genes_with_motif = sum(n_sites > 0),
            total_genes = n_distinct(gene_id)) %>%
  mutate(percent_with_motif = n_genes_with_motif / total_genes * 100)

summary_df

# Bar plot
TF_binding <- ggplot(summary_df, aes(x = TF, y = percent_with_motif)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(title = "Percent of Age-Regulated Genes with TF Binding Sites in Promoters",
       y = "% with Motif in Promoter", x = "Transcription Factor") +
  theme_minimal()

TF_binding

pdf("TF Analysis/Age_Related_Binding_Sites.pdf",
    width = 5.5,
    height = 5)
TF_binding
dev.off()

```

## TF Enrichment

This analysis uses Fishers Exact Test to determine whether there is a higher proportion of genes that contain the TF binding sites in age-related genes, or the genes that do not change with age.


```{r fisher-test}
# For this, we need a background set of promoters — e.g., all genes expressed
# I have used the list of all expressed genes from the linearity test
all_genes <- readRDS("Data/all_genes.rds") 

# Filter for non-DE genes
bg_genes <- setdiff(all_genes, ensembl_gene_id)

# Retrieve promoter sequences for background genes
bg_annot <- getBM(attributes = c("ensembl_gene_id", "chromosome_name", 
                                 "start_position", "end_position", 
                                 "strand", "external_gene_name"),
                  filters = "ensembl_gene_id",
                  values = bg_genes,
                  mart = mart)

bg_annot <- bg_annot %>%
  filter(chromosome_name %in% valid.chr)

# Same promoter extraction logic
bg_promoters <- bg_annot %>%
  mutate(
    prom_start = ifelse(strand == 1,
                        start_position - 2000,
                        end_position   - 200),
    prom_end   = ifelse(strand == 1,
                        start_position +  200,
                        end_position   +2000),
    chrom = paste0("chr", chromosome_name)
  ) %>%
  dplyr::select(chrom, prom_start, prom_end, ensembl_gene_id)


# Convert to GRanges
gr_bg <- GRanges(seqnames = bg_promoters$chrom,
                 ranges = IRanges(start = bg_promoters$prom_start,
                                  end = bg_promoters$prom_end),
                 gene_id = bg_promoters$ensembl_gene_id)

# enforce UCSC naming/style and drop any stray contigs
seqlevelsStyle(gr_bg) <- "UCSC"
gr_bg <- keepStandardChromosomes(gr_bg,
                                        pruning.mode = "coarse")

# Get promoter sequences
bg_seqs <- getSeq(BSgenome.Hsapiens.UCSC.hg38, gr_bg)
names(bg_seqs) <- gr_bg$gene_id

# Scan background sequences
bg_scan_results <- lapply(pwmList, scan_motif_hits, sequences = bg_seqs)

# Run Fisher's Exact Test for each TF
enrichment_results <- lapply(names(scan_results), function(tf) {
  
  # Count for DE genes
  de_hits <- scan_results[[tf]]
  a <- sum(de_hits$n_sites > 0)  # motif in DE
  b <- sum(de_hits$n_sites == 0) # no motif in DE
  
  # Count for background genes
  bg_hits <- bg_scan_results[[tf]]
  c <- sum(bg_hits$n_sites > 0)  # motif in BG
  d <- sum(bg_hits$n_sites == 0) # no motif in BG
  
  # Construct table
  contingency <- matrix(c(a, b, c, d), nrow = 2,
                        dimnames = list(Group = c("DE", "BG"),
                                        Motif = c("Present", "Absent")))
  
  fisher_res <- fisher.test(contingency)
  
  # Fold enrichment
  fold_enrich <- (a / (a + b)) / (c / (c + d))
  
  data.frame(TF = tf,
             p_value = fisher_res$p.value,
             odds_ratio = fisher_res$estimate,
             fold_enrichment = fold_enrich,
             DE_with_motif = a,
             DE_total = a + b,
             BG_with_motif = c,
             BG_total = c + d)
})

# Combine results
enrichment_df <- bind_rows(enrichment_results)
enrichment_df <- enrichment_df %>% mutate(p_adj = p.adjust(p_value, method = "BH"))
enrichment_df

# Plot
TF_enrichment <- ggplot(enrichment_df, aes(x = TF, y = fold_enrichment, fill = -log10(p_value))) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = sprintf("p=%.3g", p_value)), vjust = -0.5) +
  labs(title = "TF Motif Enrichment in DE Genes (vs Background)",
       y = "Fold Enrichment", x = "Transcription Factor") +
  scale_fill_continuous(name = "-log10(p-value)") +
  theme_minimal()

pdf("TF Analysis/Age_Related_Enrichment.pdf",
    width = 5.5,
    height = 5)
TF_enrichment
dev.off()

```


